<!doctype html>
<html>
<head>
<title>Hoxy API Documentation</title>
<meta charset="utf8"/>
<link href='http://fonts.googleapis.com/css?family=Antic+Slab' rel='stylesheet' type='text/css'>
<link href='styles.css' rel='stylesheet' type='text/css'>
<link href='api.css' rel='stylesheet' type='text/css'>
<script src="jquery.js"></script>
<script type="text/javascript" src="jquery.syntaxhighlighter.js"></script>
<script type="text/javascript">$.SyntaxHighlighter.init({themes:['google']});</script>
</head>
<body>
<div id="outer">
<div id="inner">

<h1>API Documentation</h1>

<h2>Main Module</h2>

<div class="api-detail" id="hoxy">
  <h3><a href="#hoxy">hoxy <span class="tldr">Main module.</span></a></h3>
  <div class="api-detail-content">
    <pre class="language-javascript code">
      var hoxy = require('hoxy');
    </pre>
  </div>
</div>

<div class="api-detail" id="hoxy-forever">
  <h3><a href="#hoxy-forever">hoxy.forever(<span class="args">[handler]</span>) <span class="tldr">Don't exit process on uncaught errors.</span></a></h3>
  <div class="api-detail-content">
    <p>
      This is a convenience function. Cause uncaught errors to be printed to stderr.
    </p>
    <pre class="language-javascript code">
      hoxy.forever();
    </pre>
    <p>
      Or, call callback on uncaught errors.
    </p>
    <pre class="language-javascript code">
      hoxy.forever(function(err){
        console.error(err.stack);
      });
    </pre>
  </div>
</div>

<h2>Class Proxy</h2>

<div class="api-detail" id="hoxy-start">
  <h3><a href="#hoxy-start">new hoxy.Proxy(<span class="args">options</span>) <span class="tldr">Construct a new proxy.</span></a></h3>
  <div class="api-detail-content">
    <p>
      Start a proxy server listening on port 8080.
    </p>
    <pre class="language-javascript code">
      var hoxy = require('hoxy');
      var proxy = new hoxy.Proxy().listen(8080);
    </pre>
    <p>
      Start a new reverse proxy on port 8080.
    </p>
    <pre class="language-javascript code">
      var hoxy = require('hoxy');
      var proxy = new hoxy.Proxy({
        reverse: 'http://example.com'
      }).listen(8080);
    </pre>
  </div>
</div>

<div class="api-detail" id="hoxy-log">
  <h3><a href="#hoxy-log">proxy.log(<span class="args">levels, handler</span>) <span class="tldr">Logging helper.</span></a></h3>
  <div class="api-detail-content">
    <p>
      Print logging events to <code>stderr</code>.
    </p>
    <pre class="language-javascript code">
      proxy.log('error warn debug');
    </pre>
    <p>
      Print logging events to various writable streams.
    </p>
    <pre class="language-javascript code">
      proxy.log('error warn debug', process.stderr);
      proxy.log('info', process.stdout);
    </pre>
    <p>
      Explicitly handle logging events.
    </p>
    <pre class="language-javascript code">
      proxy.log('error warn', function(event){
        console.log(event.level + ': ' + event.message);
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="proxy-intercept">
  <h3><a href="#proxy-intercept">proxy.intercept(<span class="args">options, handler</span>) <span class="tldr">Intercept requests or responses.</span></a></h3>
  <div class="api-detail-content">
    <p>
      Intercept all requests.
    </p>
    <pre class="language-javascript code">
      proxy.intercept('request', function(req, resp){
        console.log('request made to: '+req.url);
      });
    </pre>
    <p>
      More verbose, but identical to the above.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({phase:'request'}, function(req, resp){
        console.log('request made to: '+req.url);
      });
    </pre>
    <p>
      Intercepts with arity of three behave asynchronously.
    </p>
    <pre class="language-javascript code">
      // make everything slow
      proxy.intercept('request', function(req, resp, done){
        setTimeout(done, 1000);
      });
    </pre>
    <p>
      Admit you screwed up.
    </p>
    <pre class="language-javascript code">
      proxy.intercept('request', function(req, resp){
        throw new Error('I screwed up.');
      });
      proxy.intercept('request', function(req, resp, done){
        done(new Error('I screwed up.'));
      });
    </pre>
    <p>
      Intercept all GETs to a certain host.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        method: 'GET',
        host: 'example.com'
      }, function(req, resp){
        console.log('request made to: '+req.url);
      });
    </pre>
    <p>
      Intercept <code>text/html</code> responses, exposing the response body as the <code>$</code> variable.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        mimeType: 'text/html',
        as: '$'
      }, function(req, resp){
        resp.$('title').text('all your titles are belong to us');
      });
    </pre>
    <p>
      Intercept <code>UTF-8</code> responses, exposing the response body as the <code>string</code> variable.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        contentType: /utf\-8/i,
        as: 'string'
      }, function(req, resp){
        console.log(resp.string);
      });
    </pre>
    <p>
      Intercept <code>application/json</code> responses, exposing the request body as the <code>json</code> variable.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        mimeType: 'application/json',
        as: 'json'
      }, function(req, resp){
        console.log(req.json.email_address);
      });
    </pre>
    <p>
      All possible options.
    </p>
    <table>
      <caption>General options</caption>
      <thead>
        <tr>
          <th>name</th>
          <th class="type">type</th>
          <th>required</th>
          <th>description</th>
        </tr>
      </thead>
      <body>
        <tr>
          <td>phase</td>
          <td class="type">string</td>
          <td>yes</td>
          <td>
            Which phase to intercept. Accepted values:
            <ul>
              <li><code>request</code> - When proxy has received request.</li>
              <li><code>request-sent</code> - When proxy has sent request.</li>
              <li><code>response</code> - When proxy has received response.</li>
              <li><code>response-sent</code> - When proxy has sent response.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>as</td>
          <td class="type">string</td>
          <td>no</td>
          <td>
            Expose the request or response body (depending on the phase) as data of a certain type.
            If the content type is incompatible, this intercept action is skipped and a warning is logged.
            Hoxy normally streams request and response bodies through.
            If <code>as</code> is present, however, hoxy will buffer the entire request or response body into memory.
            Accepted values:
            <ul>
              <li><code>$</code> - A DOM object similar to jQuery. See <a href="https://github.com/MatthewMueller/cheerio">cheerio</a>.</li>
              <li><code>json</code> - A JavaScript object containing JSON.</li>
              <li><code>string</code> - A plain string.</li>
              <li><code>buffers</code> - An array of buffers.</li>
              <li><code>params</code> - A JavaScript object containing name/value pairs.</li>
            </ul>
            Note, hoxy attempts to load the data as the given type. You'll likely want to use filtering in tandem with some of these. E.g. use <code>$</code> in response phase with a text/html mime type.
          </td>
        </tr>
      </body>
    </table>
    <p>
      Note that all non-undefined filtering/matching options are logically ANDed together.
    </p>
    <table>
      <caption>Filtering options</caption>
      <thead>
        <tr>
          <th>name</th>
          <th class="type">type</th>
          <th>required</th>
          <th>description</th>
        </tr>
      </thead>
      <body>
        <tr>
          <td>protocol</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the request protocol.</td>
        </tr>
        <tr>
          <td>method</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the all-uppercase HTTP request method.</td>
        </tr>
        <tr>
          <td>host</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the host, including the :port, if present.</td>
        </tr>
        <tr>
          <td>hostname</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the host, not including :port.</td>
        </tr>
        <tr>
          <td>port</td>
          <td class="type">number | string | regexp</td>
          <td>no</td>
          <td>Match the port number.</td>
        </tr>
        <tr>
          <td>url</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the request URL. Patterns like <code>/foo/*</code> are allowed. See <a href="https://github.com/bjoerge/route-pattern">route-pattern</a>.</td>
        </tr>
        <tr>
          <td>fullUrl</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the full request URL including protocol and hostname. Patterns like <code>/foo/*</code> are allowed. See <a href="https://github.com/bjoerge/route-pattern">route-pattern</a>.</td>
        </tr>
        <tr>
          <td>contentType</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match the full content-type header of the request or response (depending on the phase).</td>
        </tr>
        <tr>
          <td>mimeType</td>
          <td class="type">string | regexp</td>
          <td>no</td>
          <td>Match just the mime type portion of the <code>content-type</code> header of the request or response (depending on the phase).</td>
        </tr>
        <tr>
          <td>filter</td>
          <td class="type">function(req, resp)</td>
          <td>no</td>
          <td>A function that receives <code>req</code> and <code>resp</code> args, returning <code>true</code> or <code>false</code> depending on whether the intercept should be called. Non-async.</td>
        </tr>
      </body>
    </table>
  </div>
</div>

<div class="api-detail" id="proxy-close">
  <h3><a href="#proxy-close">proxy.close(<span class="args"></span>) <span class="tldr">stop the proxy server</span></a></h3>
  <div class="api-detail-content">
    <p>
      Cause the proxy to stop receiving requests. Finalizes and/or cleans up any resources the proxy uses internally.
    </p>
    <pre class="language-javascript code">
      proxy.close();
    </pre>
  </div>
</div>

<h2>Class Request</h2>

<p>
  An instance of this is passed as the first argument to every intercept handler.
  Altering its values during the <code>request</code> phase changes the nature of the request.
  This object becomes read-only during all other phases, so altering its values during those phases isn't allowed.
</p>

<div class="api-detail" id="request-protocol">
  <h3><a href="#request-protocol">request.protocol {string} <span class="tldr">protocol used by this request</span></a></h3>
  <div class="api-detail-content">
    <p>
      The protocol used to contact the destination server.
      Includes a colon but not slashes, like <code>http:</code> Setting this to <code>https:</code> requires providing keys and running the proxy server in encrypted mode.
    </p>
    <p>
      NOTE: encrypted mode is not yet implemented.
      At the moment, only <code>http:</code> is supported.
    </p>
  </div>
</div>

<div class="api-detail" id="request-hostname">
  <h3><a href="#request-hostname">request.hostname {string} <span class="tldr">name of destination server</span></a></h3>
  <div class="api-detail-content">
    <p>
      The name of the destination server, sans port.
    </p>
  </div>
</div>

<div class="api-detail" id="request-port">
  <h3><a href="#request-port">request.port {number} <span class="tldr">port being connected to</span></a></h3>
  <div class="api-detail-content">
    <p>
      The port on which the destination server is contacted.
    </p>
  </div>
</div>

<div class="api-detail" id="request-method">
  <h3><a href="#request-method">request.method {string} <span class="tldr">http request method</span></a></h3>
  <div class="api-detail-content">
    <p>
      The all-caps HTTP method used in the request to the destination server. Lowercase values are converted to uppercase internally.
    </p>
  </div>
</div>

<div class="api-detail" id="request-headers">
  <h3><a href="#request-headers">request.headers {object} <span class="tldr">http request headers</span></a></h3>
  <div class="api-detail-content">
    <p>
      The HTTP headers used in the request. Header names are all-lowercase, such as <code>cookie</code>.
    </p>
  </div>
</div>

<div class="api-detail" id="request-url">
  <h3><a href="#request-url">request.url {string} <span class="tldr">url of requested resource</span></a></h3>
  <div class="api-detail-content">
    <p>
      Root-relative request URL, including query string, like <code>/foo/bar?baz=qux</code>
    </p>
  </div>
</div>

<div class="api-detail" id="request-json">
  <h3><a href="#request-json">request.json {object} <span class="tldr">json object of request body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the request as <code>json</code>, this will be a <abbr title="plain old javascript object">POJO</abbr> containing the JSON request body.
      Changes made to this object will be reflected in the request body the server receives, via <code>JSON.stringify()</code>.
      If you haven't intercepted the request as <code>json</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        as: 'json',
        method: 'PUT',
        fulUrl: 'http://example.com/users/:id'
      }, function(req, resp){
        // sign everyone up for promo emails
        // whenever they save their preferences
        req.json.prefs.subscriptions = 'all';
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="request-params">
  <h3><a href="#request-params">request.params {object} <span class="tldr">params of post/put body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the request as <code>params</code>, this will be a <abbr title="plain old javascript object">POJO</abbr> containing the name/value form parameters of the request body (i.e., for a application/x-www-form-urlencoded POST request). Changes made to this object will be reflected in the request body the server receives, via Node's <code>querystring.stringify()</code>. If you haven't intercepted the request as <code>params</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        as: 'params',
        method: 'POST',
        fullUrl: 'http://example.com/register'
      }, function(req, resp){
        // log someone's zip code when they register
        console.log(req.params['zip']);
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="request-string">
  <h3><a href="#request-string">request.string {string} <span class="tldr">request body as a string</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the request as <code>string</code>, this will be a string containing the request body. Overwriting this object will change the request body the server receives. If you haven't intercepted the request as <code>string</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        as: 'string',
        url: /\.html$/
      }, function(req, resp){
        // save all pages
        fs.writeFile(req.url, req.string, function(err){
          if (err) console.error('oops!');
        });
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="request-buffers">
  <h3><a href="#request-buffers">request.buffers {array} <span class="tldr">binary data of request body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the request as <code>buffers</code>, this will be an array containing Node.js buffer objects.
      Changes made to this object will be reflected in the request body the server receives.
      If you haven't intercepted the request as <code>buffers</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'request',
        as: 'buffers',
        method: 'POST',
        fullUrl: 'http://example.com/images'
      }, function(req, resp){
        // req.buffers contains uploaded image
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="request-slow">
  <h3><a href="#request-slow">request.slow(<span class="args">options</span>) <span class="tldr">simulate slow a connection</span></a></h3>
  <div class="api-detail-content">
    <p>
      Set a minimum latency and maximum transfer rate for this request. Useful for simulating slow internet connectivity.
    </p>
    <pre class="language-javascript code">
      // Simulate upload speed of 10,000 bytes per second
      proxy.intercept('request', function(req, resp){
        req.slow({rate:10000}); // bytes per second
      });
    </pre>
    <pre class="language-javascript code">
      // Simulate a 500-1000ms delay on every request.
      proxy.intercept('request', function(req, resp){
        req.slow({latency:randint(500, 1000)});
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="request-fullUrl">
  <h3><a href="#request-fullUrl">request.fullUrl(<span class="args"></span>) <span class="tldr">absolute url convenience function</span></a></h3>
  <div class="api-detail-content">
    <p>
      Convenience method to assemble and return the absolute URL represented by this request.
    </p>
    <div class="params">
      <h4>@return {string} - An absolute URL starting with <code>http://</code></h4>
    </div>
  </div>
</div>

<h2>Class Response</h2>

<p>
  An instance of this is passed as the second argument to every intercept handler. This object is unpopulated during the <code>request</code> and <code>request-sent</code> phases. Altering its values during the <code>request</code> phase suppresses the call to the destination server, with the understanding that you intended to replace the contents of the response. Altering its values during the <code>response</code> phase changes the nature of the response to the client. This object is read-only during the <code>request-sent</code> and <code>response-sent</code> phases, where altering its values is not allowed.
</p>

<div class="api-detail" id="response-statusCode">
  <h3><a href="#response-statusCode">response.statusCode {number} <span class="tldr">http response code</span></a></h3>
  <div class="api-detail-content">
    <p>
      The HTTP response status code sent to the client.
    </p>
  </div>
</div>

<div class="api-detail" id="response-headers">
  <h3><a href="#response-headers">response.headers {object} <span class="tldr">http response headers</span></a></h3>
  <div class="api-detail-content">
    <p>
      The HTTP headers used in the response. Header names are all-lowercase, such as <code>content-type</code>.
    </p>
  </div>
</div>

<div class="api-detail" id="response-cheerio">
  <h3><a href="#response-cheerio">response.$ {cheerio} <span class="tldr">dom of response body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the response as <code>$</code>, this will be a <a href="https://github.com/MatthewMueller/cheerio">cheerio</a> object, which provides a jQuery-like interface into the content body. Changes made via this object will be reflected in the response body the client receives, via <code>$.html()</code>. If you haven't intercepted the response as <code>$</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        as: '$',
        fullUrl: 'http://example.com/page.html'
      }, function(req, resp){
        // change the title of the page
        resp.$('title').text('Fake Title!');
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="response-json">
  <h3><a href="#response-json">response.json {object} <span class="tldr">json object of response body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the response as <code>json</code>, this will be a <abbr title="plain old javascript object">POJO</abbr> containing the JSON response body. Changes made to this object will be reflected in the response body the client receives, via <code>JSON.stringify()</code>. If you haven't intercepted the response as <code>json</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        as: 'json',
        method: 'GET',
        fullUrl: 'http://example.com/users/123'
      }, function(req, resp){
        // arbitrarily manipulate the response json
        resp.json.foo = 'bar';
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="response-string">
  <h3><a href="#response-string">response.string {string} <span class="tldr">response body as a string</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the response as <code>string</code>, this will be a string containing the response body. Overwriting this object will change the response body the client receives. If you haven't intercepted the response as <code>string</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        as: 'string',
        fullUrl: 'http://example.com/page.html'
      }, function(req, resp){
        // print page to log
        console.log(resp.string);
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="response-buffers">
  <h3><a href="#response-buffers">response.buffers {array} <span class="tldr">binary data of response body</span></a></h3>
  <div class="api-detail-content">
    <p>
      If you intercept the response as <code>buffers</code>, this will be an array containing Node.js buffer objects. Changes made to this object will be reflected in the response body the client receives. If you haven't intercepted the response as <code>buffers</code>, this will be undefined.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: 'response',
        as: 'buffers',
        fullUrl: 'http://example.com/image.jpg'
      }, function(req, resp){
        // resp.buffers contains a jpg
      });
    </pre>
  </div>
</div>

<div class="api-detail" id="response-slow">
  <h3><a href="#response-slow">response.slow(<span class="args">options</span>) <span class="tldr">simulate a slow connection</span></a></h3>
  <div class="api-detail-content">
    <p>
      Set a minimum latency and maximum transfer rate for this response. Useful for simulating slow internet connectivity.
    </p>
    <pre class="language-javascript code">
      // Simulate download speed of 100,000 bytes per second
      proxy.intercept('response', function(req, resp){
        resp.slow({rate:100000}); // bytes per second
      });
    </pre>
    <pre class="language-javascript code">
      // Simulate a 500-1000ms delay on every response.
      proxy.intercept('response', function(req, resp){
        resp.slow({latency:randint(500, 1000)});
      });
    </pre>
  </div>
</div>

<h2>Class Cycle</h2>

<p>
  An instance of this is the context (the <code>this</code> object) in calls to intercept handlers.
  It represents a single request/response cycle.
  It provides a number of methods not associated specifically to either the request or response.
</p>

<div class="api-detail" id="cycle-data">
  <h3><a href="#cycle-data">this.data(<span class="args">name, [value]</span>) <span class="tldr">store arbitrary data</span></a></h3>
  <div class="api-detail-content">
    <p>
      The same <code>Cycle</code> instance is shared across all intercept handlers for a given request/response cycle.
      This method is a scratch pad for arbitrary data, in case for example you want to set some data in one phase and access it in another.
    </p>
    <pre class="language-javascript code">
      proxy.intercept('request', function(){
        this.data('request', Date.now());
      });
      proxy.intercept('request-sent', function(){
        this.data('request-sent', Date.now());
      });
      proxy.intercept('response', function(){
        this.data('response', Date.now());
      });
      proxy.intercept('response-sent', function(){
        this.data('response-sent', Date.now());
        console.log('Proxy started receiving request: ',  this.data('request'));
        console.log('Proxy finished sending request: ',   this.data('request-sent'));
        console.log('Proxy started receiving response: ', this.data('response'));
        console.log('Proxy finished sending response: ',  this.data('response-sent'));
      });
    </pre>
    <div class="params">
      <h4>@param <code>name</code> {string}</h4>
      <p>
        Name of the data to be stored.
      </p>
      <h4>@param <code>value</code> {*}</h4>
      <p>
        Optional. If not provided, this method behaves as a getter. If provided, behaves as a setter.
      </p>
      <h4>@return {*} - The value being read/written.</h4>
    </div>
  </div>
</div>

<div class="api-detail" id="cycle-serve">
  <h3><a href="#cycle-serve">this.serve(<span class="args">docroot, [url], callback</span>) <span class="tldr">provision response from local disk</span></a></h3>
  <div class="api-detail-content">
    <p>
      Serve static files from the local filesystem by replacing the docroot of the destination server with a local docroot. This method only differs from <code>this.ghost()</code> in how it behaves when a file isn't found in the local docroot. If a file is found in the local docroot, that file is used to populate/overwrite the response. If a file is not found in the local docroot, the response is populated/overwritten with a 404, even if the file exists on the destination server.
    </p>
    <p>
      Because this method populates the response, the standard rules apply for what that entails in the various phases. For example, if it populates the response during the request phase, it will prevent the destination server from being contacted. If in the response phase, it will overwrite the response.
    </p>
    <div class="params">
      <h4>@param <code>docroot</code> {string}</h4>
      <p>
        Path on the local filesystem to serve out of.
      </p>
      <h4>@param <code>url</code> {string}</h4>
      <p>
        Optional. The URL to be served. If not provided, the request URL is used. Note that this URL is rooted to the docroot, not the filesystem root.
      </p>
      <h4>@param <code>callback</code> {function([err])}</h4>
      <p>
        Called when finished. If an error occurred, the <code>err</code> parameter will be present.
      </p>
    </div>
  </div>
</div>

<div class="api-detail" id="cycle-ghost">
<h3><a href="#cycle-ghost">this.ghost(<span class="args">docroot, [url], callback</span>) <span class="tldr">provision response from local disk</span></a></h3>
  <div class="api-detail-content">
    <p>
      Serve static files from the local filesystem by overlaying a local docroot over the docroot of the destination server. This method only differs from <code>this.serve()</code> in how it behaves when a file isn't found in the local docroot. If a file is found in the local docroot, the response is populated using that file. If a file is not found in the local docroot, the response remains unaffected.
    </p>
    <p>
      Because this method populates the response, the standard rules apply for what that entails in the various phases. For example, if it populates the response during the request phase, it will prevent the destination server from being contacted. If in the response phase, it will overwrite the response.
    </p>
    <div class="params">
      <h4>@param <code>docroot</code> {string}</h4>
      <p>
        Path on the local filesystem to serve out of.
      </p>
      <h4>@param <code>url</code> {string}</h4>
      <p>
        Optional. The URL to be served. If not provided, the request URL is used. Note that this URL is rooted to the docroot, not the filesystem root.
      </p>
      <h4>@param <code>callback</code> {function([err])}</h4>
      <p>
        Called when finished. If an error occurred, the <code>err</code> parameter will be present.
      </p>
    </div>
  </div>
</div>


</div>
</div>

<script>
function expand(hash){
  var $el = $(hash);
  if ($el.length) {
    var $content = $el.find('.api-detail-content');
    $content.slideDown(200);
  }
}
if (location.hash) {
  expand(location.hash);
}
$(window).on('hashchange', function(){
  if (location.hash) {
    expand(location.hash);
  }
});
$('h3 a[href]').on('click', function(ev){
  ev.preventDefault();
  var hash = this.href.substring(this.href.indexOf('#'));
  var $el = $(hash);
  var $content = $el.find('.api-detail-content');
  if ($content.is(':visible')) {
    $content.slideUp(200);
  } else {
    $content.slideDown(200);
  }
});

function ts(){return this.line;}

$('pre.language-javascript.code').syntaxHighlight();

</script>

</body>
</html>
